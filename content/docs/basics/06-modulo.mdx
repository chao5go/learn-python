---
title: 取模与取余
description: "取模 %、整除 //，循环下标与奇偶判断"
---

# 取模与取余

Python 里用 **`%`** 得到余数（取模/取余），用 **`//`** 得到整除结果。LeetCode 里常用于**循环下标**、**奇偶判断**、**哈希分桶**等。

## 基本用法

<PythonPlayground code={`# 取余：a % b = a 除以 b 的余数
print(7 % 3)   # 1
print(10 % 2)  # 0，整除
print(8 % 5)   # 3

# 整除：a // b = 舍去小数部分
print(7 // 3)   # 2
print(10 // 2)  # 5
print(-7 // 3)  # -3（向下取整）`} />

## 正数时：余数在 [0, b-1]

被除数是正数时，`a % b` 的结果一定在 `0` 到 `b-1` 之间，很适合做**循环下标**和**哈希桶**。

<PythonPlayground code={`# 循环下标：长度 n 的数组，下标 i 往后走 k 步
n = 5
i = 3
k = 2
next_i = (i + k) % n
print(next_i)   # 0，从 3 走 2 步到 0（环形）

# 等价：往前走
prev_i = (i - 1 + n) % n
print(prev_i)   # 2`} />

## 奇偶判断

`n % 2 == 0` 表示偶数，`n % 2 == 1` 表示奇数。

<PythonPlayground code={`for n in [4, 5, 0]:
    print(n, "偶数" if n % 2 == 0 else "奇数")

# 4 偶数, 5 奇数, 0 偶数`} />

## 哈希分桶

用 `x % m` 把数映射到 `0..m-1`，常用于哈希表桶下标、环形缓冲区。

<PythonPlayground code={`# 例如：按 3 分桶
for x in [2, 5, 8, 11]:
    bucket = x % 3
    print(f"{x} -> 桶 {bucket}")

# 2->2, 5->2, 8->2, 11->2`} />

## 负数取模（了解即可）

Python 的 `%` 结果符号与**除数**一致，且满足 `(a // b) * b + a % b == a`。刷题时多数是正数运算，遇到负数可先转成「等价正数」再取模。

<PythonPlayground code={`# 负数取模：结果与除数同号
print(-7 % 3)   # 2  （-7 = -3*3 + 2）
print(7 % -3)   # -2

# 若只要 [0, b-1]：先加 n 再取模
def mod_positive(a, b):
    return (a % b + b) % b

print(mod_positive(-1, 5))   # 4
print(mod_positive(-7, 3))   # 2`} />

## `divmod(a, b)`：一次拿到商和余数

Python 里有个很实用的内置函数 `divmod(a, b)`，会返回 `(a // b, a % b)`，很多题里能让代码更清爽。

<PythonPlayground code={`q, r = divmod(17, 5)
print(q, r)  # 3 2

# 常见：把分钟换算成 "小时:分钟"
total_minutes = 135
hour, minute = divmod(total_minutes, 60)
print(f"{hour}:{minute:02d}")  # 2:15`} />

## 同余（刷题高频）

如果 `a % m == b % m`，我们说 `a` 与 `b` 在模 `m` 意义下**同余**。同余最常用在：**循环/周期**、**环形数组**、**前缀和取模**、**分组计数**。

模运算有一些非常好用的“可变形”规则（适用于整数）：

- `(a + b) % m == ((a % m) + (b % m)) % m`
- `(a - b) % m == ((a % m) - (b % m)) % m`
- `(a * b) % m == ((a % m) * (b % m)) % m`

<PythonPlayground code={`m = 7
a, b = 100, 200
print((a + b) % m, ((a % m) + (b % m)) % m)  # 一样
print((a * b) % m, ((a % m) * (b % m)) % m)  # 一样`} />

## 前缀和取模：统计“能整除”的子数组（思路示例）

这是模运算在 LeetCode 里非常经典的用法之一：统计子数组和能被 `m` 整除的数量。

核心点：如果两个前缀和 `pre[i]` 与 `pre[j]` 满足 `pre[i] % m == pre[j] % m`，那么 `(pre[i] - pre[j]) % m == 0`，对应的区间和可整除。

<PythonPlayground code={`# 例子：nums 中有多少个子数组，其和能被 m 整除？
nums = [4, 5, 0, -2, -3, 1]
m = 5

cnt = {0: 1}  # 前缀和 % m 的出现次数
ans = 0
pre = 0
for x in nums:
    pre += x
    r = pre % m
    ans += cnt.get(r, 0)
    cnt[r] = cnt.get(r, 0) + 1

print(ans)  # 7`} />

## 大数取模：避免中间结果变得很大

很多题会让你输出结果对 \(10^9+7\) 取模（记作 `MOD = 1_000_000_007`）。做法是：每一步加/乘之后立刻 `% MOD`，保持数不爆炸、也更快。

<PythonPlayground code={`MOD = 1_000_000_007

# (a * b + c) % MOD 建议写成：
a, b, c = 10**18, 10**18, 123
res = (a % MOD) * (b % MOD) % MOD
res = (res + c) % MOD
print(res)

# 幂取模：pow(base, exp, mod) 是“快速幂”
print(pow(2, 100, MOD))`} />

## 常见坑

- **负数下标/往前走**：写成 `(i - k) % n` 在 Python 里也能工作，但为了跨语言/更直观，常写 `(i - k + n) % n`。
- **`//` 是向下取整**：`-7 // 3 == -3`，这会影响你推导负数相关的取模。
- **`%` 和数学里的“余数”定义不同**：Python 的 `%` 满足“余数与除数同号”，并保持 `(a // b) * b + a % b == a` 恒成立。

## 小结

| 运算     | 写法   | 含义           |
|----------|--------|----------------|
| 取余/取模 | `a % b`  | 余数，正数时在 [0, b-1] |
| 整除     | `a // b` | 商（向下取整）   |
| 商与余数 | `divmod(a, b)` | 同时得到 `(a // b, a % b)` |
| 循环下标 | `(i + k) % n` | 环形往后 k 步 |
| 奇偶     | `n % 2 == 0`  | 偶数           |
| 幂取模   | `pow(a, b, m)` | 计算 \(a^b \bmod m\)（快速幂） |
